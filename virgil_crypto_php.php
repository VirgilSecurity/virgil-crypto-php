<?php

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.13
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

// Try to load our extension if it's not already loaded.
if (!extension_loaded('virgil_crypto_php')) {
  if (strtolower(substr(PHP_OS, 0, 3)) === 'win') {
    if (!dl('php_virgil_crypto_php.dll')) return;
  } else {
    // PHP_SHLIB_SUFFIX gives 'dylib' on MacOS X but modules are 'so'.
    if (PHP_SHLIB_SUFFIX === 'dylib') {
      if (!dl('virgil_crypto_php.so')) return;
    } else {
      if (!dl('virgil_crypto_php.'.PHP_SHLIB_SUFFIX)) return;
    }
  }
}



abstract class virgil_crypto_php {
	const VIRGIL_CRYPTO_FEATURE_LOW_LEVEL_WRAP = VIRGIL_CRYPTO_FEATURE_LOW_LEVEL_WRAP;

	const VIRGIL_CRYPTO_FEATURE_PYTHIA = VIRGIL_CRYPTO_FEATURE_PYTHIA;

	const VIRGIL_CRYPTO_FEATURE_STREAM_IMPL = VIRGIL_CRYPTO_FEATURE_STREAM_IMPL;

	const VIRGIL_CRYPTO_FEATURE_PYTHIA_MT = VIRGIL_CRYPTO_FEATURE_PYTHIA_MT;

	static function virgil_pythia_blind($password,$blinded_password,$blinding_secret) {
		return virgil_pythia_blind($password,$blinded_password,$blinding_secret);
	}

	static function virgil_pythia_deblind($transformed_password,$blinding_secret,$deblinded_password) {
		return virgil_pythia_deblind($transformed_password,$blinding_secret,$deblinded_password);
	}

	static function virgil_pythia_compute_transformation_key_pair($transformation_key_id,$pythia_secret,$pythia_scope_secret,$transformation_private_key,$transformation_public_key) {
		return virgil_pythia_compute_transformation_key_pair($transformation_key_id,$pythia_secret,$pythia_scope_secret,$transformation_private_key,$transformation_public_key);
	}

	static function virgil_pythia_transform($blinded_password,$tweak,$transformation_private_key,$transformed_password,$transformed_tweak) {
		return virgil_pythia_transform($blinded_password,$tweak,$transformation_private_key,$transformed_password,$transformed_tweak);
	}

	static function virgil_pythia_prove($transformed_password,$blinded_password,$transformed_tweak,$transformation_private_key,$transformation_public_key,$proof_value_c,$proof_value_u) {
		return virgil_pythia_prove($transformed_password,$blinded_password,$transformed_tweak,$transformation_private_key,$transformation_public_key,$proof_value_c,$proof_value_u);
	}

	static function virgil_pythia_verify($transformed_password,$blinded_password,$tweak,$transformation_public_key,$proof_value_c,$proof_value_u,$verified) {
		return virgil_pythia_verify($transformed_password,$blinded_password,$tweak,$transformation_public_key,$proof_value_c,$proof_value_u,$verified);
	}

	static function virgil_pythia_get_password_update_token($previous_transformation_private_key,$new_transformation_private_key,$password_update_token) {
		return virgil_pythia_get_password_update_token($previous_transformation_private_key,$new_transformation_private_key,$password_update_token);
	}

	static function virgil_pythia_update_deblinded_with_token($deblinded_password,$password_update_token,$updated_deblinded_password) {
		return virgil_pythia_update_deblinded_with_token($deblinded_password,$password_update_token,$updated_deblinded_password);
	}
}

/* PHP Proxy Classes */
class VirgilVersion {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	static function asNumber() {
		return VirgilVersion_asNumber();
	}

	static function asString() {
		return VirgilVersion_asString();
	}

	static function majorVersion() {
		return VirgilVersion_majorVersion();
	}

	static function minorVersion() {
		return VirgilVersion_minorVersion();
	}

	static function patchVersion() {
		return VirgilVersion_patchVersion();
	}

	static function fullName() {
		return VirgilVersion_fullName();
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilVersion') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilVersion();
	}
}

abstract class VirgilDataSource {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function hasData() {
		return VirgilDataSource_hasData($this->_cPtr);
	}

	function read() {
		return VirgilDataSource_read($this->_cPtr);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilDataSource') {
			$this->_cPtr=$res;
			return;
		}
		if (get_class($this) === 'VirgilDataSource') {
			$_this = null;
		} else {
			$_this = $this;
		}
		$this->_cPtr=new_VirgilDataSource($_this);
	}
}

abstract class VirgilDataSink {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function isGood() {
		return VirgilDataSink_isGood($this->_cPtr);
	}

	function write($data) {
		VirgilDataSink_write($this->_cPtr,$data);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilDataSink') {
			$this->_cPtr=$res;
			return;
		}
		if (get_class($this) === 'VirgilDataSink') {
			$_this = null;
		} else {
			$_this = $this;
		}
		$this->_cPtr=new_VirgilDataSink($_this);
	}
}

abstract class VirgilAsn1Compatible {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}
	function __construct($h) {
		$this->_cPtr=$h;
	}

	function toAsn1() {
		return VirgilAsn1Compatible_toAsn1($this->_cPtr);
	}

	function fromAsn1($asn1) {
		VirgilAsn1Compatible_fromAsn1($this->_cPtr,$asn1);
	}
}

class VirgilKeyPair {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	const Type_RSA_256 = 0;

	const Type_RSA_512 = VirgilKeyPair_Type_RSA_512;

	const Type_RSA_1024 = VirgilKeyPair_Type_RSA_1024;

	const Type_RSA_2048 = VirgilKeyPair_Type_RSA_2048;

	const Type_RSA_3072 = VirgilKeyPair_Type_RSA_3072;

	const Type_RSA_4096 = VirgilKeyPair_Type_RSA_4096;

	const Type_RSA_8192 = VirgilKeyPair_Type_RSA_8192;

	const Type_EC_SECP192R1 = VirgilKeyPair_Type_EC_SECP192R1;

	const Type_EC_SECP224R1 = VirgilKeyPair_Type_EC_SECP224R1;

	const Type_EC_SECP256R1 = VirgilKeyPair_Type_EC_SECP256R1;

	const Type_EC_SECP384R1 = VirgilKeyPair_Type_EC_SECP384R1;

	const Type_EC_SECP521R1 = VirgilKeyPair_Type_EC_SECP521R1;

	const Type_EC_BP256R1 = VirgilKeyPair_Type_EC_BP256R1;

	const Type_EC_BP384R1 = VirgilKeyPair_Type_EC_BP384R1;

	const Type_EC_BP512R1 = VirgilKeyPair_Type_EC_BP512R1;

	const Type_EC_SECP192K1 = VirgilKeyPair_Type_EC_SECP192K1;

	const Type_EC_SECP224K1 = VirgilKeyPair_Type_EC_SECP224K1;

	const Type_EC_SECP256K1 = VirgilKeyPair_Type_EC_SECP256K1;

	const Type_EC_CURVE25519 = VirgilKeyPair_Type_EC_CURVE25519;

	const Type_FAST_EC_X25519 = VirgilKeyPair_Type_FAST_EC_X25519;

	const Type_FAST_EC_ED25519 = VirgilKeyPair_Type_FAST_EC_ED25519;

	static function generate($type,$pwd=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilKeyPair_generate($type); break;
		default: $r=VirgilKeyPair_generate($type,$pwd);
		}
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilKeyPair($r);
		}
		return $r;
	}

	static function generateRecommended($pwd=null) {
		switch (func_num_args()) {
		case 0: $r=VirgilKeyPair_generateRecommended(); break;
		default: $r=VirgilKeyPair_generateRecommended($pwd);
		}
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilKeyPair($r);
		}
		return $r;
	}

	static function generateFrom($donorKeyPair,$donorPrivateKeyPassword=null,$newKeyPairPassword=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilKeyPair_generateFrom($donorKeyPair); break;
		case 2: $r=VirgilKeyPair_generateFrom($donorKeyPair,$donorPrivateKeyPassword); break;
		default: $r=VirgilKeyPair_generateFrom($donorKeyPair,$donorPrivateKeyPassword,$newKeyPairPassword);
		}
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilKeyPair($r);
		}
		return $r;
	}

	static function generateFromKeyMaterial($type,$keyMaterial,$pwd=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilKeyPair_generateFromKeyMaterial($type,$keyMaterial); break;
		default: $r=VirgilKeyPair_generateFromKeyMaterial($type,$keyMaterial,$pwd);
		}
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilKeyPair($r);
		}
		return $r;
	}

	static function generateRecommendedFromKeyMaterial($keyMaterial,$pwd=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilKeyPair_generateRecommendedFromKeyMaterial($keyMaterial); break;
		default: $r=VirgilKeyPair_generateRecommendedFromKeyMaterial($keyMaterial,$pwd);
		}
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilKeyPair($r);
		}
		return $r;
	}

	static function isKeyPairMatch($publicKey,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilKeyPair_isKeyPairMatch($publicKey,$privateKey); break;
		default: $r=VirgilKeyPair_isKeyPairMatch($publicKey,$privateKey,$privateKeyPassword);
		}
		return $r;
	}

	static function checkPrivateKeyPassword($key,$pwd) {
		return VirgilKeyPair_checkPrivateKeyPassword($key,$pwd);
	}

	static function isPrivateKeyEncrypted($privateKey) {
		return VirgilKeyPair_isPrivateKeyEncrypted($privateKey);
	}

	static function resetPrivateKeyPassword($privateKey,$oldPassword,$newPassword) {
		return VirgilKeyPair_resetPrivateKeyPassword($privateKey,$oldPassword,$newPassword);
	}

	static function encryptPrivateKey($privateKey,$privateKeyPassword) {
		return VirgilKeyPair_encryptPrivateKey($privateKey,$privateKeyPassword);
	}

	static function decryptPrivateKey($privateKey,$privateKeyPassword) {
		return VirgilKeyPair_decryptPrivateKey($privateKey,$privateKeyPassword);
	}

	static function extractPublicKey($privateKey,$privateKeyPassword) {
		return VirgilKeyPair_extractPublicKey($privateKey,$privateKeyPassword);
	}

	static function publicKeyToPEM($publicKey) {
		return VirgilKeyPair_publicKeyToPEM($publicKey);
	}

	static function publicKeyToDER($publicKey) {
		return VirgilKeyPair_publicKeyToDER($publicKey);
	}

	static function privateKeyToPEM($privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilKeyPair_privateKeyToPEM($privateKey); break;
		default: $r=VirgilKeyPair_privateKeyToPEM($privateKey,$privateKeyPassword);
		}
		return $r;
	}

	static function privateKeyToDER($privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilKeyPair_privateKeyToDER($privateKey); break;
		default: $r=VirgilKeyPair_privateKeyToDER($privateKey,$privateKeyPassword);
		}
		return $r;
	}

	function publicKey() {
		return VirgilKeyPair_publicKey($this->_cPtr);
	}

	function privateKey() {
		return VirgilKeyPair_privateKey($this->_cPtr);
	}

	function __construct($publicKey_or_other,$privateKey=null) {
		if (is_resource($publicKey_or_other) && get_resource_type($publicKey_or_other) === '_p_virgil__crypto__VirgilKeyPair') {
			$this->_cPtr=$publicKey_or_other;
			return;
		}
		switch (func_num_args()) {
		case 1: $this->_cPtr=new_VirgilKeyPair($publicKey_or_other); break;
		default: $this->_cPtr=new_VirgilKeyPair($publicKey_or_other,$privateKey);
		}
	}
}

class VirgilAsn1Reader {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($data=null) {
		if (is_resource($data) && get_resource_type($data) === '_p_virgil__crypto__foundation__asn1__VirgilAsn1Reader') {
			$this->_cPtr=$data;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilAsn1Reader(); break;
		default: $this->_cPtr=new_VirgilAsn1Reader($data);
		}
	}

	function reset($data) {
		VirgilAsn1Reader_reset($this->_cPtr,$data);
	}

	function readInteger() {
		return VirgilAsn1Reader_readInteger($this->_cPtr);
	}

	function readBool() {
		return VirgilAsn1Reader_readBool($this->_cPtr);
	}

	function readNull() {
		VirgilAsn1Reader_readNull($this->_cPtr);
	}

	function readOctetString() {
		return VirgilAsn1Reader_readOctetString($this->_cPtr);
	}

	function readUTF8String() {
		return VirgilAsn1Reader_readUTF8String($this->_cPtr);
	}

	function readData() {
		return VirgilAsn1Reader_readData($this->_cPtr);
	}

	function readContextTag($tag) {
		return VirgilAsn1Reader_readContextTag($this->_cPtr,$tag);
	}

	function readOID() {
		return VirgilAsn1Reader_readOID($this->_cPtr);
	}

	function readSequence() {
		return VirgilAsn1Reader_readSequence($this->_cPtr);
	}

	function readSet() {
		return VirgilAsn1Reader_readSet($this->_cPtr);
	}
}

class VirgilAsn1Writer {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($capacity=null) {
		if (is_resource($capacity) && get_resource_type($capacity) === '_p_virgil__crypto__foundation__asn1__VirgilAsn1Writer') {
			$this->_cPtr=$capacity;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilAsn1Writer(); break;
		default: $this->_cPtr=new_VirgilAsn1Writer($capacity);
		}
	}

	function reset($capacity=null) {
		switch (func_num_args()) {
		case 0: VirgilAsn1Writer_reset($this->_cPtr); break;
		default: VirgilAsn1Writer_reset($this->_cPtr,$capacity);
		}
	}

	function finish() {
		return VirgilAsn1Writer_finish($this->_cPtr);
	}

	function writeInteger($value) {
		return VirgilAsn1Writer_writeInteger($this->_cPtr,$value);
	}

	function writeBool($value) {
		return VirgilAsn1Writer_writeBool($this->_cPtr,$value);
	}

	function writeNull() {
		return VirgilAsn1Writer_writeNull($this->_cPtr);
	}

	function writeOctetString($data) {
		return VirgilAsn1Writer_writeOctetString($this->_cPtr,$data);
	}

	function writeUTF8String($data) {
		return VirgilAsn1Writer_writeUTF8String($this->_cPtr,$data);
	}

	function writeContextTag($tag,$len) {
		return VirgilAsn1Writer_writeContextTag($this->_cPtr,$tag,$len);
	}

	function writeData($data) {
		return VirgilAsn1Writer_writeData($this->_cPtr,$data);
	}

	function writeOID($oid) {
		return VirgilAsn1Writer_writeOID($this->_cPtr,$oid);
	}

	function writeSequence($len) {
		return VirgilAsn1Writer_writeSequence($this->_cPtr,$len);
	}

	function writeSet($set) {
		return VirgilAsn1Writer_writeSet($this->_cPtr,$set);
	}
}

class VirgilCMSKeyTransRecipient extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		$func = 'VirgilCMSKeyTransRecipient_'.$var.'_set';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr,$value);
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		$func = 'VirgilCMSKeyTransRecipient_'.$var.'_get';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr);
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if (function_exists('VirgilCMSKeyTransRecipient_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__foundation__cms__VirgilCMSKeyTransRecipient') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilCMSKeyTransRecipient(); break;
		default: $this->_cPtr=new_VirgilCMSKeyTransRecipient($other);
		}
	}
}

class VirgilCMSPasswordRecipient extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		$func = 'VirgilCMSPasswordRecipient_'.$var.'_set';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr,$value);
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		$func = 'VirgilCMSPasswordRecipient_'.$var.'_get';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr);
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if (function_exists('VirgilCMSPasswordRecipient_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__foundation__cms__VirgilCMSPasswordRecipient') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilCMSPasswordRecipient(); break;
		default: $this->_cPtr=new_VirgilCMSPasswordRecipient($other);
		}
	}
}

class VirgilCMSEncryptedContent extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'encryptedContent') return VirgilCMSEncryptedContent_encryptedContent_set($this->_cPtr,$value);
		if ($var === 'contentEncryptionAlgorithm') return VirgilCMSEncryptedContent_contentEncryptionAlgorithm_set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'encryptedContent') return VirgilCMSEncryptedContent_encryptedContent_get($this->_cPtr);
		if ($var === 'contentEncryptionAlgorithm') return VirgilCMSEncryptedContent_contentEncryptionAlgorithm_get($this->_cPtr);
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if (function_exists('VirgilCMSEncryptedContent_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__foundation__cms__VirgilCMSEncryptedContent') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilCMSEncryptedContent(); break;
		default: $this->_cPtr=new_VirgilCMSEncryptedContent($other);
		}
	}
}

class VirgilCMSEnvelopedData extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		$func = 'VirgilCMSEnvelopedData_'.$var.'_set';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr,$value);
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'encryptedContent') return new VirgilCMSEncryptedContent(VirgilCMSEnvelopedData_encryptedContent_get($this->_cPtr));
		if ($var === 'keyTransRecipients') return VirgilCMSEnvelopedData_keyTransRecipients_get($this->_cPtr);
		if ($var === 'passwordRecipients') return VirgilCMSEnvelopedData_passwordRecipients_get($this->_cPtr);
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if (function_exists('VirgilCMSEnvelopedData_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__foundation__cms__VirgilCMSEnvelopedData') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilCMSEnvelopedData(); break;
		default: $this->_cPtr=new_VirgilCMSEnvelopedData($other);
		}
	}
}

class VirgilCMSContent extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'content') return VirgilCMSContent_content_set($this->_cPtr,$value);
		if ($var === 'contentType') return VirgilCMSContent_contentType_set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'content') return VirgilCMSContent_content_get($this->_cPtr);
		if ($var === 'contentType') return VirgilCMSContent_contentType_get($this->_cPtr);
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if (function_exists('VirgilCMSContent_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	const Type_Data = 0;

	const Type_SignedData = VirgilCMSContent_Type_SignedData;

	const Type_EnvelopedData = VirgilCMSContent_Type_EnvelopedData;

	const Type_DigestedData = VirgilCMSContent_Type_DigestedData;

	const Type_EncryptedData = VirgilCMSContent_Type_EncryptedData;

	const Type_AuthenticatedData = VirgilCMSContent_Type_AuthenticatedData;

	const Type_SignedAndEnvelopedData = VirgilCMSContent_Type_SignedAndEnvelopedData;

	const Type_DataWithAttributes = VirgilCMSContent_Type_DataWithAttributes;

	const Type_EncryptedPrivateKeyInfo = VirgilCMSContent_Type_EncryptedPrivateKeyInfo;

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__foundation__cms__VirgilCMSContent') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilCMSContent(); break;
		default: $this->_cPtr=new_VirgilCMSContent($other);
		}
	}
}

class VirgilCMSContentInfo extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'cmsContent') return VirgilCMSContentInfo_cmsContent_set($this->_cPtr,$value);
		if ($var === 'customParams') return VirgilCMSContentInfo_customParams_set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'cmsContent') return new VirgilCMSContent(VirgilCMSContentInfo_cmsContent_get($this->_cPtr));
		if ($var === 'customParams') return new VirgilCustomParams(VirgilCMSContentInfo_customParams_get($this->_cPtr));
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if (function_exists('VirgilCMSContentInfo_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	static function defineSize($data) {
		return VirgilCMSContentInfo_defineSize($data);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__foundation__cms__VirgilCMSContentInfo') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilCMSContentInfo(); break;
		default: $this->_cPtr=new_VirgilCMSContentInfo($other);
		}
	}
}

class VirgilHash extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	const Algorithm_MD5 = 0;

	const Algorithm_SHA1 = VirgilHash_Algorithm_SHA1;

	const Algorithm_SHA224 = VirgilHash_Algorithm_SHA224;

	const Algorithm_SHA256 = VirgilHash_Algorithm_SHA256;

	const Algorithm_SHA384 = VirgilHash_Algorithm_SHA384;

	const Algorithm_SHA512 = VirgilHash_Algorithm_SHA512;

	function name() {
		return VirgilHash_name($this->_cPtr);
	}

	function algorithm() {
		return VirgilHash_algorithm($this->_cPtr);
	}

	function type() {
		return VirgilHash_type($this->_cPtr);
	}

	function size() {
		return VirgilHash_size($this->_cPtr);
	}

	function hash($data) {
		return VirgilHash_hash($this->_cPtr,$data);
	}

	function start() {
		VirgilHash_start($this->_cPtr);
	}

	function update($data) {
		VirgilHash_update($this->_cPtr,$data);
	}

	function finish() {
		return VirgilHash_finish($this->_cPtr);
	}

	function hmac($key,$data) {
		return VirgilHash_hmac($this->_cPtr,$key,$data);
	}

	function hmacStart($key) {
		VirgilHash_hmacStart($this->_cPtr,$key);
	}

	function hmacReset() {
		VirgilHash_hmacReset($this->_cPtr);
	}

	function hmacUpdate($data) {
		VirgilHash_hmacUpdate($this->_cPtr,$data);
	}

	function hmacFinish() {
		return VirgilHash_hmacFinish($this->_cPtr);
	}

	function __construct($alg_or_name_or_rhs=null) {
		if (is_resource($alg_or_name_or_rhs) && get_resource_type($alg_or_name_or_rhs) === '_p_virgil__crypto__foundation__VirgilHash') {
			$this->_cPtr=$alg_or_name_or_rhs;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilHash(); break;
		default: $this->_cPtr=new_VirgilHash($alg_or_name_or_rhs);
		}
	}
}

class VirgilKDF extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	const Algorithm_KDF1 = 0;

	const Algorithm_KDF2 = VirgilKDF_Algorithm_KDF2;

	function __construct($alg_or_name=null) {
		if (is_resource($alg_or_name) && get_resource_type($alg_or_name) === '_p_virgil__crypto__foundation__VirgilKDF') {
			$this->_cPtr=$alg_or_name;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilKDF(); break;
		default: $this->_cPtr=new_VirgilKDF($alg_or_name);
		}
	}

	function name() {
		return VirgilKDF_name($this->_cPtr);
	}

	function derive($in,$outSize) {
		return VirgilKDF_derive($this->_cPtr,$in,$outSize);
	}
}

class VirgilSymmetricCipher extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	const Padding_PKCS7 = 0;

	const Padding_OneAndZeros = VirgilSymmetricCipher_Padding_OneAndZeros;

	const Padding_ZerosAndLen = VirgilSymmetricCipher_Padding_ZerosAndLen;

	const Padding_Zeros = VirgilSymmetricCipher_Padding_Zeros;

	const Padding_None = VirgilSymmetricCipher_Padding_None;

	const Algorithm_AES_128_CBC = 0;

	const Algorithm_AES_128_GCM = VirgilSymmetricCipher_Algorithm_AES_128_GCM;

	const Algorithm_AES_256_CBC = VirgilSymmetricCipher_Algorithm_AES_256_CBC;

	const Algorithm_AES_256_GCM = VirgilSymmetricCipher_Algorithm_AES_256_GCM;

	function __construct($algorithm_or_name=null) {
		if (is_resource($algorithm_or_name) && get_resource_type($algorithm_or_name) === '_p_virgil__crypto__foundation__VirgilSymmetricCipher') {
			$this->_cPtr=$algorithm_or_name;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilSymmetricCipher(); break;
		default: $this->_cPtr=new_VirgilSymmetricCipher($algorithm_or_name);
		}
	}

	function isInited() {
		return VirgilSymmetricCipher_isInited($this->_cPtr);
	}

	function name() {
		return VirgilSymmetricCipher_name($this->_cPtr);
	}

	function blockSize() {
		return VirgilSymmetricCipher_blockSize($this->_cPtr);
	}

	function ivSize() {
		return VirgilSymmetricCipher_ivSize($this->_cPtr);
	}

	function keySize() {
		return VirgilSymmetricCipher_keySize($this->_cPtr);
	}

	function keyLength() {
		return VirgilSymmetricCipher_keyLength($this->_cPtr);
	}

	function authTagLength() {
		return VirgilSymmetricCipher_authTagLength($this->_cPtr);
	}

	function isEncryptionMode() {
		return VirgilSymmetricCipher_isEncryptionMode($this->_cPtr);
	}

	function isDecryptionMode() {
		return VirgilSymmetricCipher_isDecryptionMode($this->_cPtr);
	}

	function isAuthMode() {
		return VirgilSymmetricCipher_isAuthMode($this->_cPtr);
	}

	function isSupportPadding() {
		return VirgilSymmetricCipher_isSupportPadding($this->_cPtr);
	}

	function iv() {
		return VirgilSymmetricCipher_iv($this->_cPtr);
	}

	function setEncryptionKey($key) {
		VirgilSymmetricCipher_setEncryptionKey($this->_cPtr,$key);
	}

	function setDecryptionKey($key) {
		VirgilSymmetricCipher_setDecryptionKey($this->_cPtr,$key);
	}

	function setPadding($padding) {
		VirgilSymmetricCipher_setPadding($this->_cPtr,$padding);
	}

	function setIV($iv) {
		VirgilSymmetricCipher_setIV($this->_cPtr,$iv);
	}

	function setAuthData($authData) {
		VirgilSymmetricCipher_setAuthData($this->_cPtr,$authData);
	}

	function reset() {
		VirgilSymmetricCipher_reset($this->_cPtr);
	}

	function clear() {
		VirgilSymmetricCipher_clear($this->_cPtr);
	}

	function crypt($input,$iv) {
		return VirgilSymmetricCipher_crypt($this->_cPtr,$input,$iv);
	}

	function update($input) {
		return VirgilSymmetricCipher_update($this->_cPtr,$input);
	}

	function finish() {
		return VirgilSymmetricCipher_finish($this->_cPtr);
	}
}

class VirgilAsymmetricCipher extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__foundation__VirgilAsymmetricCipher') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilAsymmetricCipher();
	}

	function keySize() {
		return VirgilAsymmetricCipher_keySize($this->_cPtr);
	}

	function keyLength() {
		return VirgilAsymmetricCipher_keyLength($this->_cPtr);
	}

	static function isKeyPairMatch($publicKey,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilAsymmetricCipher_isKeyPairMatch($publicKey,$privateKey); break;
		default: $r=VirgilAsymmetricCipher_isKeyPairMatch($publicKey,$privateKey,$privateKeyPassword);
		}
		return $r;
	}

	static function isPublicKeyValid($key) {
		return VirgilAsymmetricCipher_isPublicKeyValid($key);
	}

	static function checkPublicKey($key) {
		VirgilAsymmetricCipher_checkPublicKey($key);
	}

	static function checkPrivateKeyPassword($key,$pwd) {
		return VirgilAsymmetricCipher_checkPrivateKeyPassword($key,$pwd);
	}

	static function isPrivateKeyEncrypted($privateKey) {
		return VirgilAsymmetricCipher_isPrivateKeyEncrypted($privateKey);
	}

	function setPrivateKey($key,$pwd=null) {
		switch (func_num_args()) {
		case 1: VirgilAsymmetricCipher_setPrivateKey($this->_cPtr,$key); break;
		default: VirgilAsymmetricCipher_setPrivateKey($this->_cPtr,$key,$pwd);
		}
	}

	function setPublicKey($key) {
		VirgilAsymmetricCipher_setPublicKey($this->_cPtr,$key);
	}

	function genKeyPair($type) {
		VirgilAsymmetricCipher_genKeyPair($this->_cPtr,$type);
	}

	function genKeyPairFrom($other) {
		VirgilAsymmetricCipher_genKeyPairFrom($this->_cPtr,$other);
	}

	function genKeyPairFromKeyMaterial($type,$keyMaterial) {
		VirgilAsymmetricCipher_genKeyPairFromKeyMaterial($this->_cPtr,$type,$keyMaterial);
	}

	static function computeShared($publicContext,$privateContext) {
		return VirgilAsymmetricCipher_computeShared($publicContext,$privateContext);
	}

	function exportPrivateKeyToDER($pwd=null) {
		switch (func_num_args()) {
		case 0: $r=VirgilAsymmetricCipher_exportPrivateKeyToDER($this->_cPtr); break;
		default: $r=VirgilAsymmetricCipher_exportPrivateKeyToDER($this->_cPtr,$pwd);
		}
		return $r;
	}

	function exportPublicKeyToDER() {
		return VirgilAsymmetricCipher_exportPublicKeyToDER($this->_cPtr);
	}

	function exportPrivateKeyToPEM($pwd=null) {
		switch (func_num_args()) {
		case 0: $r=VirgilAsymmetricCipher_exportPrivateKeyToPEM($this->_cPtr); break;
		default: $r=VirgilAsymmetricCipher_exportPrivateKeyToPEM($this->_cPtr,$pwd);
		}
		return $r;
	}

	function exportPublicKeyToPEM() {
		return VirgilAsymmetricCipher_exportPublicKeyToPEM($this->_cPtr);
	}

	function getKeyType() {
		return VirgilAsymmetricCipher_getKeyType($this->_cPtr);
	}

	function setKeyType($keyType) {
		VirgilAsymmetricCipher_setKeyType($this->_cPtr,$keyType);
	}

	function getPublicKeyBits() {
		return VirgilAsymmetricCipher_getPublicKeyBits($this->_cPtr);
	}

	function setPublicKeyBits($bits) {
		VirgilAsymmetricCipher_setPublicKeyBits($this->_cPtr,$bits);
	}

	function encrypt($in) {
		return VirgilAsymmetricCipher_encrypt($this->_cPtr,$in);
	}

	function decrypt($in) {
		return VirgilAsymmetricCipher_decrypt($this->_cPtr,$in);
	}

	function sign($digest,$hashType) {
		return VirgilAsymmetricCipher_sign($this->_cPtr,$digest,$hashType);
	}

	function verify($digest,$sign,$hashType) {
		return VirgilAsymmetricCipher_verify($this->_cPtr,$digest,$sign,$hashType);
	}
}

class VirgilPBE extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	const Algorithm_PKCS5 = 0;

	const Algorithm_PKCS12 = VirgilPBE_Algorithm_PKCS12;

	const kIterationCountMin = VirgilPBE_kIterationCountMin;

	function __construct($alg=null,$salt=null,$iterationCount=null) {
		if (is_resource($alg) && get_resource_type($alg) === '_p_virgil__crypto__foundation__VirgilPBE') {
			$this->_cPtr=$alg;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilPBE(); break;
		case 1: $this->_cPtr=new_VirgilPBE($alg); break;
		case 2: $this->_cPtr=new_VirgilPBE($alg,$salt); break;
		default: $this->_cPtr=new_VirgilPBE($alg,$salt,$iterationCount);
		}
	}

	function encrypt($data,$pwd) {
		return VirgilPBE_encrypt($this->_cPtr,$data,$pwd);
	}

	function decrypt($data,$pwd) {
		return VirgilPBE_decrypt($this->_cPtr,$data,$pwd);
	}
}

class VirgilHKDF {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($hashAlgorithm) {
		if (is_resource($hashAlgorithm) && get_resource_type($hashAlgorithm) === '_p_virgil__crypto__foundation__VirgilHKDF') {
			$this->_cPtr=$hashAlgorithm;
			return;
		}
		$this->_cPtr=new_VirgilHKDF($hashAlgorithm);
	}

	function derive($in,$salt,$info,$outSize) {
		return VirgilHKDF_derive($this->_cPtr,$in,$salt,$info,$outSize);
	}
}

class VirgilBase64 {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}
	function __construct($h) {
		$this->_cPtr=$h;
	}

	static function encode($data) {
		return VirgilBase64_encode($data);
	}

	static function decode($base64str) {
		return VirgilBase64_decode($base64str);
	}
}

class VirgilPBKDF extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	const kIterationCount_Default = VirgilPBKDF_kIterationCount_Default;

	const Algorithm_PBKDF2 = 0;

	function __construct($salt=null,$iterationCount=null) {
		if (is_resource($salt) && get_resource_type($salt) === '_p_virgil__crypto__foundation__VirgilPBKDF') {
			$this->_cPtr=$salt;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilPBKDF(); break;
		case 1: $this->_cPtr=new_VirgilPBKDF($salt); break;
		default: $this->_cPtr=new_VirgilPBKDF($salt,$iterationCount);
		}
	}

	function getSalt() {
		return VirgilPBKDF_getSalt($this->_cPtr);
	}

	function getIterationCount() {
		return VirgilPBKDF_getIterationCount($this->_cPtr);
	}

	function setAlgorithm($alg) {
		VirgilPBKDF_setAlgorithm($this->_cPtr,$alg);
	}

	function getAlgorithm() {
		return VirgilPBKDF_getAlgorithm($this->_cPtr);
	}

	function setHashAlgorithm($hash) {
		VirgilPBKDF_setHashAlgorithm($this->_cPtr,$hash);
	}

	function getHashAlgorithm() {
		return VirgilPBKDF_getHashAlgorithm($this->_cPtr);
	}

	function enableRecommendationsCheck() {
		VirgilPBKDF_enableRecommendationsCheck($this->_cPtr);
	}

	function disableRecommendationsCheck() {
		VirgilPBKDF_disableRecommendationsCheck($this->_cPtr);
	}

	function derive($pwd,$outSize=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilPBKDF_derive($this->_cPtr,$pwd); break;
		default: $r=VirgilPBKDF_derive($this->_cPtr,$pwd,$outSize);
		}
		return $r;
	}
}

class VirgilRandom {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function randomize($bytesNum_or_min=null,$max=null) {
		switch (func_num_args()) {
		case 0: $r=VirgilRandom_randomize($this->_cPtr); break;
		case 1: $r=VirgilRandom_randomize($this->_cPtr,$bytesNum_or_min); break;
		default: $r=VirgilRandom_randomize($this->_cPtr,$bytesNum_or_min,$max);
		}
		return $r;
	}

	function __construct($personalInfo_or_rhs) {
		if (is_resource($personalInfo_or_rhs) && get_resource_type($personalInfo_or_rhs) === '_p_virgil__crypto__foundation__VirgilRandom') {
			$this->_cPtr=$personalInfo_or_rhs;
			return;
		}
		$this->_cPtr=new_VirgilRandom($personalInfo_or_rhs);
	}
}

class VirgilConfig {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	static function hasFeatureStreamImpl() {
		return VirgilConfig_hasFeatureStreamImpl();
	}

	static function hasFeaturePythiaImpl() {
		return VirgilConfig_hasFeaturePythiaImpl();
	}

	static function hasFeaturePythiaMultiThread() {
		return VirgilConfig_hasFeaturePythiaMultiThread();
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilConfig') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilConfig();
	}
}

class VirgilCustomParams extends VirgilAsn1Compatible {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilAsn1Compatible::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilAsn1Compatible::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilAsn1Compatible::__isset($var);
	}

	function isEmpty() {
		return VirgilCustomParams_isEmpty($this->_cPtr);
	}

	function setInteger($key,$value) {
		VirgilCustomParams_setInteger($this->_cPtr,$key,$value);
	}

	function getInteger($key) {
		return VirgilCustomParams_getInteger($this->_cPtr,$key);
	}

	function removeInteger($key) {
		VirgilCustomParams_removeInteger($this->_cPtr,$key);
	}

	function setString($key,$value) {
		VirgilCustomParams_setString($this->_cPtr,$key,$value);
	}

	function getString($key) {
		return VirgilCustomParams_getString($this->_cPtr,$key);
	}

	function removeString($key) {
		VirgilCustomParams_removeString($this->_cPtr,$key);
	}

	function setData($key,$value) {
		VirgilCustomParams_setData($this->_cPtr,$key,$value);
	}

	function getData($key) {
		return VirgilCustomParams_getData($this->_cPtr,$key);
	}

	function removeData($key) {
		VirgilCustomParams_removeData($this->_cPtr,$key);
	}

	function clear() {
		VirgilCustomParams_clear($this->_cPtr);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__VirgilCustomParams') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilCustomParams(); break;
		default: $this->_cPtr=new_VirgilCustomParams($other);
		}
	}
}

class VirgilCipherBase {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilCipherBase') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilCipherBase();
	}

	function addKeyRecipient($recipientId,$publicKey) {
		VirgilCipherBase_addKeyRecipient($this->_cPtr,$recipientId,$publicKey);
	}

	function removeKeyRecipient($recipientId) {
		VirgilCipherBase_removeKeyRecipient($this->_cPtr,$recipientId);
	}

	function keyRecipientExists($recipientId) {
		return VirgilCipherBase_keyRecipientExists($this->_cPtr,$recipientId);
	}

	function addPasswordRecipient($pwd) {
		VirgilCipherBase_addPasswordRecipient($this->_cPtr,$pwd);
	}

	function removePasswordRecipient($pwd) {
		VirgilCipherBase_removePasswordRecipient($this->_cPtr,$pwd);
	}

	function passwordRecipientExists($password) {
		return VirgilCipherBase_passwordRecipientExists($this->_cPtr,$password);
	}

	function removeAllRecipients() {
		VirgilCipherBase_removeAllRecipients($this->_cPtr);
	}

	function getContentInfo() {
		return VirgilCipherBase_getContentInfo($this->_cPtr);
	}

	function setContentInfo($contentInfo) {
		VirgilCipherBase_setContentInfo($this->_cPtr,$contentInfo);
	}

	static function defineContentInfoSize($data) {
		return VirgilCipherBase_defineContentInfoSize($data);
	}

	function customParams() {
		$r=VirgilCipherBase_customParams($this->_cPtr);
		if (!is_resource($r)) return $r;
		return new VirgilCustomParams($r);
	}

	static function computeShared($publicKey,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilCipherBase_computeShared($publicKey,$privateKey); break;
		default: $r=VirgilCipherBase_computeShared($publicKey,$privateKey,$privateKeyPassword);
		}
		return $r;
	}
}

class VirgilCipher extends VirgilCipherBase {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilCipherBase::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilCipherBase::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilCipherBase::__isset($var);
	}

	function encrypt($data,$embedContentInfo=true) {
		return VirgilCipher_encrypt($this->_cPtr,$data,$embedContentInfo);
	}

	function decryptWithKey($encryptedData,$recipientId,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 3: $r=VirgilCipher_decryptWithKey($this->_cPtr,$encryptedData,$recipientId,$privateKey); break;
		default: $r=VirgilCipher_decryptWithKey($this->_cPtr,$encryptedData,$recipientId,$privateKey,$privateKeyPassword);
		}
		return $r;
	}

	function decryptWithPassword($encryptedData,$pwd) {
		return VirgilCipher_decryptWithPassword($this->_cPtr,$encryptedData,$pwd);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilCipher') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilCipher();
	}
}

class VirgilChunkCipher extends VirgilCipherBase {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilCipherBase::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilCipherBase::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilCipherBase::__isset($var);
	}

	const kPreferredChunkSize = VirgilChunkCipher_kPreferredChunkSize;

	function encrypt($source,$sink,$embedContentInfo=true,$preferredChunkSize=null) {
		switch (func_num_args()) {
		case 2: case 3: VirgilChunkCipher_encrypt($this->_cPtr,$source,$sink,$embedContentInfo); break;
		default: VirgilChunkCipher_encrypt($this->_cPtr,$source,$sink,$embedContentInfo,$preferredChunkSize);
		}
	}

	function decryptWithKey($source,$sink,$recipientId,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 4: VirgilChunkCipher_decryptWithKey($this->_cPtr,$source,$sink,$recipientId,$privateKey); break;
		default: VirgilChunkCipher_decryptWithKey($this->_cPtr,$source,$sink,$recipientId,$privateKey,$privateKeyPassword);
		}
	}

	function decryptWithPassword($source,$sink,$pwd) {
		VirgilChunkCipher_decryptWithPassword($this->_cPtr,$source,$sink,$pwd);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilChunkCipher') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilChunkCipher();
	}
}

class VirgilSeqCipher extends VirgilCipherBase {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilCipherBase::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilCipherBase::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilCipherBase::__isset($var);
	}

	function startEncryption() {
		return VirgilSeqCipher_startEncryption($this->_cPtr);
	}

	function startDecryptionWithKey($recipientId,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: VirgilSeqCipher_startDecryptionWithKey($this->_cPtr,$recipientId,$privateKey); break;
		default: VirgilSeqCipher_startDecryptionWithKey($this->_cPtr,$recipientId,$privateKey,$privateKeyPassword);
		}
	}

	function startDecryptionWithPassword($pwd) {
		VirgilSeqCipher_startDecryptionWithPassword($this->_cPtr,$pwd);
	}

	function process($data) {
		return VirgilSeqCipher_process($this->_cPtr,$data);
	}

	function finish() {
		return VirgilSeqCipher_finish($this->_cPtr);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilSeqCipher') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilSeqCipher();
	}
}

class VirgilSignerBase {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($hashAlgorithm=null) {
		if (is_resource($hashAlgorithm) && get_resource_type($hashAlgorithm) === '_p_virgil__crypto__VirgilSignerBase') {
			$this->_cPtr=$hashAlgorithm;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilSignerBase(); break;
		default: $this->_cPtr=new_VirgilSignerBase($hashAlgorithm);
		}
	}

	function getHashAlgorithm() {
		return VirgilSignerBase_getHashAlgorithm($this->_cPtr);
	}

	function signHash($digest,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilSignerBase_signHash($this->_cPtr,$digest,$privateKey); break;
		default: $r=VirgilSignerBase_signHash($this->_cPtr,$digest,$privateKey,$privateKeyPassword);
		}
		return $r;
	}

	function verifyHash($digest,$signature,$publicKey) {
		return VirgilSignerBase_verifyHash($this->_cPtr,$digest,$signature,$publicKey);
	}
}

class VirgilSigner extends VirgilSignerBase {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilSignerBase::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilSignerBase::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilSignerBase::__isset($var);
	}

	function __construct($hashAlgorithm=null) {
		if (is_resource($hashAlgorithm) && get_resource_type($hashAlgorithm) === '_p_virgil__crypto__VirgilSigner') {
			$this->_cPtr=$hashAlgorithm;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilSigner(); break;
		default: $this->_cPtr=new_VirgilSigner($hashAlgorithm);
		}
	}

	function sign($data,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilSigner_sign($this->_cPtr,$data,$privateKey); break;
		default: $r=VirgilSigner_sign($this->_cPtr,$data,$privateKey,$privateKeyPassword);
		}
		return $r;
	}

	function verify($data,$sign,$publicKey) {
		return VirgilSigner_verify($this->_cPtr,$data,$sign,$publicKey);
	}
}

class VirgilSeqSigner extends VirgilSignerBase {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilSignerBase::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilSignerBase::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilSignerBase::__isset($var);
	}

	function __construct($hashAlgorithm=null) {
		if (is_resource($hashAlgorithm) && get_resource_type($hashAlgorithm) === '_p_virgil__crypto__VirgilSeqSigner') {
			$this->_cPtr=$hashAlgorithm;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilSeqSigner(); break;
		default: $this->_cPtr=new_VirgilSeqSigner($hashAlgorithm);
		}
	}

	function startSigning() {
		VirgilSeqSigner_startSigning($this->_cPtr);
	}

	function startVerifying($signature) {
		VirgilSeqSigner_startVerifying($this->_cPtr,$signature);
	}

	function update($data) {
		VirgilSeqSigner_update($this->_cPtr,$data);
	}

	function sign($privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilSeqSigner_sign($this->_cPtr,$privateKey); break;
		default: $r=VirgilSeqSigner_sign($this->_cPtr,$privateKey,$privateKeyPassword);
		}
		return $r;
	}

	function verify($publicKey) {
		return VirgilSeqSigner_verify($this->_cPtr,$publicKey);
	}
}

class VirgilStreamSigner extends VirgilSignerBase {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilSignerBase::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilSignerBase::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilSignerBase::__isset($var);
	}

	function __construct($hashAlgorithm=null) {
		if (is_resource($hashAlgorithm) && get_resource_type($hashAlgorithm) === '_p_virgil__crypto__VirgilStreamSigner') {
			$this->_cPtr=$hashAlgorithm;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilStreamSigner(); break;
		default: $this->_cPtr=new_VirgilStreamSigner($hashAlgorithm);
		}
	}

	function sign($source,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilStreamSigner_sign($this->_cPtr,$source,$privateKey); break;
		default: $r=VirgilStreamSigner_sign($this->_cPtr,$source,$privateKey,$privateKeyPassword);
		}
		return $r;
	}

	function verify($source,$sign,$publicKey) {
		return VirgilStreamSigner_verify($this->_cPtr,$source,$sign,$publicKey);
	}
}

class VirgilStreamCipher extends VirgilCipherBase {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		VirgilCipherBase::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return VirgilCipherBase::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return VirgilCipherBase::__isset($var);
	}

	function encrypt($source,$sink,$embedContentInfo=true) {
		VirgilStreamCipher_encrypt($this->_cPtr,$source,$sink,$embedContentInfo);
	}

	function decryptWithKey($source,$sink,$recipientId,$privateKey,$privateKeyPassword=null) {
		switch (func_num_args()) {
		case 4: VirgilStreamCipher_decryptWithKey($this->_cPtr,$source,$sink,$recipientId,$privateKey); break;
		default: VirgilStreamCipher_decryptWithKey($this->_cPtr,$source,$sink,$recipientId,$privateKey,$privateKeyPassword);
		}
	}

	function decryptWithPassword($source,$sink,$pwd) {
		VirgilStreamCipher_decryptWithPassword($this->_cPtr,$source,$sink,$pwd);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__VirgilStreamCipher') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilStreamCipher();
	}
}

class VirgilTinyCipher {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	const PackageSize_Min = 113;

	const PackageSize_Short_SMS = 120;

	const PackageSize_Long_SMS = 1200;

	function __construct($packageSize=null) {
		if (is_resource($packageSize) && get_resource_type($packageSize) === '_p_virgil__crypto__VirgilTinyCipher') {
			$this->_cPtr=$packageSize;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilTinyCipher(); break;
		default: $this->_cPtr=new_VirgilTinyCipher($packageSize);
		}
	}

	function reset() {
		VirgilTinyCipher_reset($this->_cPtr);
	}

	function encrypt($data,$recipientPublicKey) {
		VirgilTinyCipher_encrypt($this->_cPtr,$data,$recipientPublicKey);
	}

	function encryptAndSign($data,$recipientPublicKey,$senderPrivateKey,$senderPrivateKeyPassword=null) {
		switch (func_num_args()) {
		case 3: VirgilTinyCipher_encryptAndSign($this->_cPtr,$data,$recipientPublicKey,$senderPrivateKey); break;
		default: VirgilTinyCipher_encryptAndSign($this->_cPtr,$data,$recipientPublicKey,$senderPrivateKey,$senderPrivateKeyPassword);
		}
	}

	function getPackageCount() {
		return VirgilTinyCipher_getPackageCount($this->_cPtr);
	}

	function getPackage($index) {
		return VirgilTinyCipher_getPackage($this->_cPtr,$index);
	}

	function addPackage($package) {
		VirgilTinyCipher_addPackage($this->_cPtr,$package);
	}

	function isPackagesAccumulated() {
		return VirgilTinyCipher_isPackagesAccumulated($this->_cPtr);
	}

	function decrypt($recipientPrivateKey,$recipientPrivateKeyPassword=null) {
		switch (func_num_args()) {
		case 1: $r=VirgilTinyCipher_decrypt($this->_cPtr,$recipientPrivateKey); break;
		default: $r=VirgilTinyCipher_decrypt($this->_cPtr,$recipientPrivateKey,$recipientPrivateKeyPassword);
		}
		return $r;
	}

	function verifyAndDecrypt($senderPublicKey,$recipientPrivateKey,$recipientPrivateKeyPassword=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilTinyCipher_verifyAndDecrypt($this->_cPtr,$senderPublicKey,$recipientPrivateKey); break;
		default: $r=VirgilTinyCipher_verifyAndDecrypt($this->_cPtr,$senderPublicKey,$recipientPrivateKey,$recipientPrivateKeyPassword);
		}
		return $r;
	}
}

class VirgilByteArrayUtils {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}
	function __construct($h) {
		$this->_cPtr=$h;
	}

	static function jsonToBytes($json) {
		return VirgilByteArrayUtils_jsonToBytes($json);
	}

	static function stringToBytes($str) {
		return VirgilByteArrayUtils_stringToBytes($str);
	}

	static function bytesToString($array) {
		return VirgilByteArrayUtils_bytesToString($array);
	}

	static function hexToBytes($hexStr) {
		return VirgilByteArrayUtils_hexToBytes($hexStr);
	}

	static function bytesToHex($array,$formatted=false) {
		return VirgilByteArrayUtils_bytesToHex($array,$formatted);
	}
}

class VirgilPFSEncryptedMessage {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($sessionIdentifier,$salt=null,$cipherText=null) {
		if (is_resource($sessionIdentifier) && get_resource_type($sessionIdentifier) === '_p_virgil__crypto__pfs__VirgilPFSEncryptedMessage') {
			$this->_cPtr=$sessionIdentifier;
			return;
		}
		$this->_cPtr=new_VirgilPFSEncryptedMessage($sessionIdentifier,$salt,$cipherText);
	}

	function getSessionIdentifier() {
		return VirgilPFSEncryptedMessage_getSessionIdentifier($this->_cPtr);
	}

	function getSalt() {
		return VirgilPFSEncryptedMessage_getSalt($this->_cPtr);
	}

	function getCipherText() {
		return VirgilPFSEncryptedMessage_getCipherText($this->_cPtr);
	}
}

class VirgilPFSPublicKey {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($key=null) {
		if (is_resource($key) && get_resource_type($key) === '_p_virgil__crypto__pfs__VirgilPFSPublicKey') {
			$this->_cPtr=$key;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilPFSPublicKey(); break;
		default: $this->_cPtr=new_VirgilPFSPublicKey($key);
		}
	}

	function isEmpty() {
		return VirgilPFSPublicKey_isEmpty($this->_cPtr);
	}

	function getKey() {
		return VirgilPFSPublicKey_getKey($this->_cPtr);
	}
}

class VirgilPFSPrivateKey {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function isEmpty() {
		return VirgilPFSPrivateKey_isEmpty($this->_cPtr);
	}

	function getKey() {
		return VirgilPFSPrivateKey_getKey($this->_cPtr);
	}

	function getPassword() {
		return VirgilPFSPrivateKey_getPassword($this->_cPtr);
	}

	function __construct($key_or_other=null,$password=null) {
		if (is_resource($key_or_other) && get_resource_type($key_or_other) === '_p_virgil__crypto__pfs__VirgilPFSPrivateKey') {
			$this->_cPtr=$key_or_other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilPFSPrivateKey(); break;
		case 1: $this->_cPtr=new_VirgilPFSPrivateKey($key_or_other); break;
		default: $this->_cPtr=new_VirgilPFSPrivateKey($key_or_other,$password);
		}
	}
}

class VirgilPFSInitiatorPublicInfo {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($identityPublicKey,$ephemeralPublicKey=null) {
		if (is_resource($identityPublicKey) && get_resource_type($identityPublicKey) === '_p_virgil__crypto__pfs__VirgilPFSInitiatorPublicInfo') {
			$this->_cPtr=$identityPublicKey;
			return;
		}
		$this->_cPtr=new_VirgilPFSInitiatorPublicInfo($identityPublicKey,$ephemeralPublicKey);
	}

	function getIdentityPublicKey() {
		$r=VirgilPFSInitiatorPublicInfo_getIdentityPublicKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPublicKey($r);
		}
		return $r;
	}

	function getEphemeralPublicKey() {
		$r=VirgilPFSInitiatorPublicInfo_getEphemeralPublicKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPublicKey($r);
		}
		return $r;
	}
}

class VirgilPFSInitiatorPrivateInfo {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($identityPrivateKey,$ephemeralPrivateKey=null) {
		if (is_resource($identityPrivateKey) && get_resource_type($identityPrivateKey) === '_p_virgil__crypto__pfs__VirgilPFSInitiatorPrivateInfo') {
			$this->_cPtr=$identityPrivateKey;
			return;
		}
		$this->_cPtr=new_VirgilPFSInitiatorPrivateInfo($identityPrivateKey,$ephemeralPrivateKey);
	}

	function getIdentityPrivateKey() {
		$r=VirgilPFSInitiatorPrivateInfo_getIdentityPrivateKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPrivateKey($r);
		}
		return $r;
	}

	function getEphemeralPrivateKey() {
		$r=VirgilPFSInitiatorPrivateInfo_getEphemeralPrivateKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPrivateKey($r);
		}
		return $r;
	}
}

class VirgilPFSResponderPublicInfo {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($identityPublicKey,$longTermPublicKey=null,$oneTimePublicKey=null) {
		if (is_resource($identityPublicKey) && get_resource_type($identityPublicKey) === '_p_virgil__crypto__pfs__VirgilPFSResponderPublicInfo') {
			$this->_cPtr=$identityPublicKey;
			return;
		}
		switch (func_num_args()) {
		case 2: $this->_cPtr=new_VirgilPFSResponderPublicInfo($identityPublicKey,$longTermPublicKey); break;
		default: $this->_cPtr=new_VirgilPFSResponderPublicInfo($identityPublicKey,$longTermPublicKey,$oneTimePublicKey);
		}
	}

	function getIdentityPublicKey() {
		$r=VirgilPFSResponderPublicInfo_getIdentityPublicKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPublicKey($r);
		}
		return $r;
	}

	function getLongTermPublicKey() {
		$r=VirgilPFSResponderPublicInfo_getLongTermPublicKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPublicKey($r);
		}
		return $r;
	}

	function getOneTimePublicKey() {
		$r=VirgilPFSResponderPublicInfo_getOneTimePublicKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPublicKey($r);
		}
		return $r;
	}
}

class VirgilPFSResponderPrivateInfo {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($identityPrivateKey,$longTermPrivateKey=null,$oneTimePrivateKey=null) {
		if (is_resource($identityPrivateKey) && get_resource_type($identityPrivateKey) === '_p_virgil__crypto__pfs__VirgilPFSResponderPrivateInfo') {
			$this->_cPtr=$identityPrivateKey;
			return;
		}
		switch (func_num_args()) {
		case 2: $this->_cPtr=new_VirgilPFSResponderPrivateInfo($identityPrivateKey,$longTermPrivateKey); break;
		default: $this->_cPtr=new_VirgilPFSResponderPrivateInfo($identityPrivateKey,$longTermPrivateKey,$oneTimePrivateKey);
		}
	}

	function getIdentityPrivateKey() {
		$r=VirgilPFSResponderPrivateInfo_getIdentityPrivateKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPrivateKey($r);
		}
		return $r;
	}

	function getLongTermPrivateKey() {
		$r=VirgilPFSResponderPrivateInfo_getLongTermPrivateKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPrivateKey($r);
		}
		return $r;
	}

	function getOneTimePrivateKey() {
		$r=VirgilPFSResponderPrivateInfo_getOneTimePrivateKey($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSPrivateKey($r);
		}
		return $r;
	}
}

class VirgilPFSSession {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($identifier=null,$encryptionSecretKey=null,$decryptionSecretKey=null,$additionalData=null) {
		if (is_resource($identifier) && get_resource_type($identifier) === '_p_virgil__crypto__pfs__VirgilPFSSession') {
			$this->_cPtr=$identifier;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilPFSSession(); break;
		case 1: $this->_cPtr=new_VirgilPFSSession($identifier); break;
		case 2: $this->_cPtr=new_VirgilPFSSession($identifier,$encryptionSecretKey); break;
		case 3: $this->_cPtr=new_VirgilPFSSession($identifier,$encryptionSecretKey,$decryptionSecretKey); break;
		default: $this->_cPtr=new_VirgilPFSSession($identifier,$encryptionSecretKey,$decryptionSecretKey,$additionalData);
		}
	}

	function isEmpty() {
		return VirgilPFSSession_isEmpty($this->_cPtr);
	}

	function getIdentifier() {
		return VirgilPFSSession_getIdentifier($this->_cPtr);
	}

	function getEncryptionSecretKey() {
		return VirgilPFSSession_getEncryptionSecretKey($this->_cPtr);
	}

	function getDecryptionSecretKey() {
		return VirgilPFSSession_getDecryptionSecretKey($this->_cPtr);
	}

	function getAdditionalData() {
		return VirgilPFSSession_getAdditionalData($this->_cPtr);
	}
}

class VirgilPFS {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_virgil__crypto__pfs__VirgilPFS') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_VirgilPFS();
	}

	function startInitiatorSession($initiatorPrivateInfo,$responderPublicInfo,$additionalData=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilPFS_startInitiatorSession($this->_cPtr,$initiatorPrivateInfo,$responderPublicInfo); break;
		default: $r=VirgilPFS_startInitiatorSession($this->_cPtr,$initiatorPrivateInfo,$responderPublicInfo,$additionalData);
		}
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSSession($r);
		}
		return $r;
	}

	function startResponderSession($responderPrivateInfo,$initiatorPublicInfo,$additionalData=null) {
		switch (func_num_args()) {
		case 2: $r=VirgilPFS_startResponderSession($this->_cPtr,$responderPrivateInfo,$initiatorPublicInfo); break;
		default: $r=VirgilPFS_startResponderSession($this->_cPtr,$responderPrivateInfo,$initiatorPublicInfo,$additionalData);
		}
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSSession($r);
		}
		return $r;
	}

	function encrypt($data) {
		$r=VirgilPFS_encrypt($this->_cPtr,$data);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSEncryptedMessage($r);
		}
		return $r;
	}

	function decrypt($encryptedMessage) {
		return VirgilPFS_decrypt($this->_cPtr,$encryptedMessage);
	}

	function getSession() {
		$r=VirgilPFS_getSession($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPFSSession($r);
		}
		return $r;
	}

	function setSession($session) {
		VirgilPFS_setSession($this->_cPtr,$session);
	}
}

class VirgilPythiaBlindResult {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function blindedPassword() {
		return VirgilPythiaBlindResult_blindedPassword($this->_cPtr);
	}

	function blindingSecret() {
		return VirgilPythiaBlindResult_blindingSecret($this->_cPtr);
	}

	function __construct($blindedPassword_or_other,$blindingSecret=null) {
		if (is_resource($blindedPassword_or_other) && get_resource_type($blindedPassword_or_other) === '_p_virgil__crypto__pythia__VirgilPythiaBlindResult') {
			$this->_cPtr=$blindedPassword_or_other;
			return;
		}
		switch (func_num_args()) {
		case 1: $this->_cPtr=new_VirgilPythiaBlindResult($blindedPassword_or_other); break;
		default: $this->_cPtr=new_VirgilPythiaBlindResult($blindedPassword_or_other,$blindingSecret);
		}
	}
}

class VirgilPythiaContext {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__pythia__VirgilPythiaContext') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilPythiaContext(); break;
		default: $this->_cPtr=new_VirgilPythiaContext($other);
		}
	}
}

class VirgilPythiaTransformationKeyPair {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function publicKey() {
		return VirgilPythiaTransformationKeyPair_publicKey($this->_cPtr);
	}

	function privateKey() {
		return VirgilPythiaTransformationKeyPair_privateKey($this->_cPtr);
	}

	function __construct($privateKey_or_other,$publicKey=null) {
		if (is_resource($privateKey_or_other) && get_resource_type($privateKey_or_other) === '_p_virgil__crypto__pythia__VirgilPythiaTransformationKeyPair') {
			$this->_cPtr=$privateKey_or_other;
			return;
		}
		switch (func_num_args()) {
		case 1: $this->_cPtr=new_VirgilPythiaTransformationKeyPair($privateKey_or_other); break;
		default: $this->_cPtr=new_VirgilPythiaTransformationKeyPair($privateKey_or_other,$publicKey);
		}
	}
}

class VirgilPythiaProveResult {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function proofValueC() {
		return VirgilPythiaProveResult_proofValueC($this->_cPtr);
	}

	function proofValueU() {
		return VirgilPythiaProveResult_proofValueU($this->_cPtr);
	}

	function __construct($proofValueC_or_other,$proofValueU=null) {
		if (is_resource($proofValueC_or_other) && get_resource_type($proofValueC_or_other) === '_p_virgil__crypto__pythia__VirgilPythiaProveResult') {
			$this->_cPtr=$proofValueC_or_other;
			return;
		}
		switch (func_num_args()) {
		case 1: $this->_cPtr=new_VirgilPythiaProveResult($proofValueC_or_other); break;
		default: $this->_cPtr=new_VirgilPythiaProveResult($proofValueC_or_other,$proofValueU);
		}
	}
}

class VirgilPythiaTransformResult {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function transformedPassword() {
		return VirgilPythiaTransformResult_transformedPassword($this->_cPtr);
	}

	function transformedTweak() {
		return VirgilPythiaTransformResult_transformedTweak($this->_cPtr);
	}

	function __construct($transformedPassword_or_other,$transformedTweak=null) {
		if (is_resource($transformedPassword_or_other) && get_resource_type($transformedPassword_or_other) === '_p_virgil__crypto__pythia__VirgilPythiaTransformResult') {
			$this->_cPtr=$transformedPassword_or_other;
			return;
		}
		switch (func_num_args()) {
		case 1: $this->_cPtr=new_VirgilPythiaTransformResult($transformedPassword_or_other); break;
		default: $this->_cPtr=new_VirgilPythiaTransformResult($transformedPassword_or_other,$transformedTweak);
		}
	}
}

class VirgilPythia {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_virgil_crypto_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_virgil_crypto_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function blind($password) {
		$r=VirgilPythia_blind($this->_cPtr,$password);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPythiaBlindResult($r);
		}
		return $r;
	}

	function deblind($transformedPassword,$blindingSecret) {
		return VirgilPythia_deblind($this->_cPtr,$transformedPassword,$blindingSecret);
	}

	function computeTransformationKeyPair($transformationKeyID,$pythiaSecret,$pythiaScopeSecret) {
		$r=VirgilPythia_computeTransformationKeyPair($this->_cPtr,$transformationKeyID,$pythiaSecret,$pythiaScopeSecret);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPythiaTransformationKeyPair($r);
		}
		return $r;
	}

	function transform($blindedPassword,$tweak,$transformationPrivateKey) {
		$r=VirgilPythia_transform($this->_cPtr,$blindedPassword,$tweak,$transformationPrivateKey);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPythiaTransformResult($r);
		}
		return $r;
	}

	function prove($transformedPassword,$blindedPassword,$transformedTweak,$transformationKeyPair) {
		$r=VirgilPythia_prove($this->_cPtr,$transformedPassword,$blindedPassword,$transformedTweak,$transformationKeyPair);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new VirgilPythiaProveResult($r);
		}
		return $r;
	}

	function verify($transformedPassword,$blindedPassword,$tweak,$transformationPublicKey,$proofValueC,$proofValueU) {
		return VirgilPythia_verify($this->_cPtr,$transformedPassword,$blindedPassword,$tweak,$transformationPublicKey,$proofValueC,$proofValueU);
	}

	function getPasswordUpdateToken($previousTransformationPrivateKey,$newTransformationPrivateKey) {
		return VirgilPythia_getPasswordUpdateToken($this->_cPtr,$previousTransformationPrivateKey,$newTransformationPrivateKey);
	}

	function updateDeblindedWithToken($deblindedPassword,$passwordUpdateToken) {
		return VirgilPythia_updateDeblindedWithToken($this->_cPtr,$deblindedPassword,$passwordUpdateToken);
	}

	function __construct($other=null) {
		if (is_resource($other) && get_resource_type($other) === '_p_virgil__crypto__pythia__VirgilPythia') {
			$this->_cPtr=$other;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_VirgilPythia(); break;
		default: $this->_cPtr=new_VirgilPythia($other);
		}
	}
}


?>
